<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 跨域请求与常见解决方式 · 蒋亦雄的博客</title><meta name="description" content="跨域请求与常见解决方式 - Yixiong Jiang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://jiangyixiong.top/atom.xml" title="蒋亦雄的博客"><meta name="generator" content="Hexo 5.4.2"><link rel="alternate" href="/atom.xml" title="蒋亦雄的博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/categories/blog" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/categories/podcast" target="_self" class="nav-list-link">PODCAST</a></li><li class="nav-list-item"><a href="https://github.com/GaryXiongxiong" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/resume/" target="_self" class="nav-list-link">RESUME</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">跨域请求与常见解决方式</h1><div class="post-info">2020年9月21日</div><div class="post-content"><p>在<a href="/2020/09/19/%E5%B8%B8%E8%A7%81%E5%AE%89%E5%85%A8%E6%B5%8B%E8%AF%95%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93-1/">【常见安全测试项目总结-1】</a>这篇文章中，有提到通过CSRF攻击伪造用户请求。在学习的时候有想到既然有浏览器的同源策略，为什么还会有CSRF攻击呢？在我的记忆中，浏览器同源策略会阻止向非同源地址发送AJAX请求，在这种情况下，恶意网站伪造的用户请求是无法发送到目标站点的呀？经过进一步学习后发现：在同源策略下，浏览器发现跨域请求时，<strong>请求能发出去，服务端能收到请求并正常返回结果，只是结果被浏览器拦截了。</strong>看到这里发现自己对于跨域问题的理解还是有些肤浅，故又看了些文章写下了这篇笔记。</p>
<span id="more"></span>

<h2 id="什么是同源策略"><a href="#什么是同源策略" class="headerlink" title="什么是同源策略"></a>什么是同源策略</h2><h4 id="同源"><a href="#同源" class="headerlink" title="同源"></a>同源</h4><p>同源指目标的<strong>协议</strong>，<strong>域名</strong>，<strong>子域名</strong>，<strong>端口</strong> 均为一致，即为同源。</p>
<h4 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h4><p>同源策略对于非同源、跨域的请求设置了各种限制。这种限制并不能简单的理解为禁止获取非同源的资源（<code>&lt;img&gt;</code>,<code>&lt;link&gt;</code>,<code>&lt;script&gt;</code>标签都可以请求到非同源内容），也不能理解为禁止跨域请求（因为AJAX确实发出去了，只是服务端的响应被屏蔽了，我就是掉进了这个误区中）。准确的说，同源策略的限制如下：</p>
<blockquote>
<p>限制获取cookies、LocalStorage等存储</p>
<p>限制DOM节点</p>
<p>限制AJAX的请求结果获取</p>
</blockquote>
<p>实例使用时，我遇到的较为常见的触发这三条限制的场景为：</p>
<ul>
<li>通过AJAX调用跨域API</li>
<li>在iframe中试图修改外界DOM</li>
</ul>
<h2 id="跨域可用方案"><a href="#跨域可用方案" class="headerlink" title="跨域可用方案"></a>跨域可用方案</h2><p>那么当我们的需求遇到了同源策略的限制，应该如何解决呢？这里转述了下<a target="_blank" rel="noopener" href="https://juejin.im/post/6844903767226351623">大佬</a>总结的一些跨域解决方案：</p>
<h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>JSONP的原理是利用<code>&lt;script&gt;</code>标签没有同源限制的特性，通过<code>&lt;script&gt;</code>标签获取服务端动态生成的JSON数据。举例如下：</p>
<p>后端将返回的JSON作为参数放入一个与前端约定好的回调方法中。如约定回调方法名为callback，则后端返回以下内容：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;callback(&quot;</span>+<span class="title class_">JSON</span>Str+<span class="string">&quot;)&quot;</span></span><br></pre></td></tr></table></figure>

<p>前端则通过向页面写入<code>&lt;script&gt;</code>标签的方式来向后端地址发送get请求：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">jsonp</span>(<span class="params">&#123; url, params, callback &#125;</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> script = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&#x27;script&#x27;</span>)</span><br><span class="line">    <span class="variable language_">window</span>[callback] = <span class="keyword">function</span>(<span class="params">data</span>) &#123;</span><br><span class="line">      <span class="title function_">resolve</span>(data)</span><br><span class="line">      <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">removeChild</span>(script)</span><br><span class="line">    &#125;</span><br><span class="line">    params = &#123; ...params, callback &#125; <span class="comment">// wd=b&amp;callback=show</span></span><br><span class="line">    <span class="keyword">let</span> arrs = []</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> params) &#123;</span><br><span class="line">      arrs.<span class="title function_">push</span>(<span class="string">`<span class="subst">$&#123;key&#125;</span>=<span class="subst">$&#123;params[key]&#125;</span>`</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    script.<span class="property">src</span> = <span class="string">`<span class="subst">$&#123;url&#125;</span>?<span class="subst">$&#123;arrs.join(<span class="string">&#x27;&amp;&#x27;</span>)&#125;</span>`</span></span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="title function_">appendChild</span>(script)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">jsonp</span>(&#123;</span><br><span class="line">  <span class="attr">url</span>: <span class="string">&#x27;http://localhost:3000/say&#x27;</span>,</span><br><span class="line">  <span class="attr">params</span>: &#123; <span class="attr">wd</span>: <span class="string">&#x27;Iloveyou&#x27;</span> &#125;,</span><br><span class="line">  <span class="attr">callback</span>: <span class="string">&#x27;callback&#x27;</span></span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function"><span class="params">data</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>本质上是向页面中引入了<code>callback(JSONStr)</code>这句函数调用，调用我们在前端中预先定义好的callback函数，而数据作为参数传入了前端。</p>
<p>以上的调用方式较为麻烦，jQuery则为我们提供了封装好的JSONP调用方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.<span class="title function_">ajax</span>(&#123;</span><br><span class="line"><span class="attr">url</span>:<span class="string">&quot;http://crossdomain.com/jsonServerResponse&quot;</span>,</span><br><span class="line"><span class="attr">dataType</span>:<span class="string">&quot;jsonp&quot;</span>,</span><br><span class="line"><span class="attr">type</span>:<span class="string">&quot;get&quot;</span>,</span><br><span class="line"><span class="attr">jsonpCallback</span>:<span class="string">&quot;show&quot;</span>,</span><br><span class="line"><span class="attr">jsonp</span>:<span class="string">&quot;callback&quot;</span>,</span><br><span class="line"><span class="attr">success</span>:<span class="keyword">function</span> (<span class="params">data</span>)&#123;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(data);&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>CORS需要浏览器与后端共同支持。浏览器会自动进行CORS通信，而后端则需要配置。</p>
<p>后端需要通过设置Access-Control-Allow-Origin来开启CORS。这个属性用于设置那些域名可以访问该资源。</p>
<p>前端在通过CORS发送跨域请求时，分为简单请求与发杂请求两种情况。简单请求指方法为<code>GET</code> / <code>post</code> /  <code>HEAD</code>之一，且Content-Type为<code>test/plain</code> / <code>multipart/form-data</code> /  <code>application/x-www-form-urlencoded</code>之一。其余的请求为复杂请求，复杂请求在通信前会增加一起http请求，来确定服务端是否允许跨域请求。</p>
<h4 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h4><p>既然我们知道同源策略限制的是非同源的请求，那么只要我们通过Nginx等支持反向代理的服务器将我们需要的地址代理到同一域名端口下，非同源请求自然就变成了同源请求。</p>
<p>我们需要做的是反向代理目标接口，并且修改cookie中的domain信息，以供当前域写入cookie，实现跨域带cookie请求。示例Nginx配置如下：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// proxy服务器</span></span><br><span class="line">server <span class="punctuation">&#123;</span></span><br><span class="line">    listen       <span class="number">81</span>;</span><br><span class="line">    server_name  www.domain1.com;</span><br><span class="line">    location / <span class="punctuation">&#123;</span></span><br><span class="line">        proxy_pass   http<span class="punctuation">:</span><span class="comment">//www.domain2.com:8080;  #反向代理</span></span><br><span class="line">        proxy_cookie_domain www.domain2.com www.domain1.com; #修改cookie里域名</span><br><span class="line">        index  index.html index.htm;</span><br><span class="line"></span><br><span class="line">        # 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br><span class="line">        add_header Access-Control-Allow-Origin http<span class="punctuation">:</span><span class="comment">//www.domain1.com; </span></span><br><span class="line">        #当前端只跨域不带cookie时，可为*</span><br><span class="line">        add_header Access-Control-Allow-Credentials <span class="literal"><span class="keyword">true</span></span>;</span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>

<p>以上三种是最主流的解决跨域访问的方案了，其余还有一些方法，个人觉得不是很常用，感兴趣的朋友可以从文末的引用中看下大佬的原文。</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><blockquote>
<p><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903767226351623">https://juejin.im/post/6844903767226351623</a></p>
<p><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000020962174">https://segmentfault.com/a/1190000020962174</a></p>
</blockquote>
</div></article></div></main><footer><div class="paginator"><a href="/2020/09/22/JWT%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E7%A4%BA%E4%BE%8B/" class="prev">PREV</a><a href="/2020/09/19/LeetCode%E7%AC%94%E8%AE%B0-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/" class="next">NEXT</a></div><div class="copyright"><p><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv">页面访问量:<span id="busuanzi_value_page_pv"></span></span></p><p>© 2018 - 2025 <a href="http://jiangyixiong.top">Yixiong Jiang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>