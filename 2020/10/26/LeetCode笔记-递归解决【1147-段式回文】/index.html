<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> LeetCode笔记-递归解决【1147-段式回文】 · 蒋亦雄的博客</title><meta name="description" content="LeetCode笔记-递归解决【1147-段式回文】 - Yixiong Jiang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://jiangyixiong.top/atom.xml" title="蒋亦雄的博客"><meta name="generator" content="Hexo 5.0.0"><link rel="alternate" href="/atom.xml" title="蒋亦雄的博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/categories/blog" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/categories/podcast" target="_self" class="nav-list-link">PODCAST</a></li><li class="nav-list-item"><a href="https://github.com/GaryXiongxiong" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/resume/" target="_self" class="nav-list-link">RESUME</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">LeetCode笔记-递归解决【1147-段式回文】</h1><div class="post-info">2020年10月26日</div><div class="post-content"><p>段式回文 其实与 一般回文 类似，只不过是最小的单位是 一段字符 而不是 单个字母。</p>
<p>举个例子，对于一般回文 “<code>abcba</code>“ 是回文，而 “<code>volvo</code>“ 不是，但如果我们把 “<code>volvo</code>“ 分为 “<code>vo</code>“、”<code>l</code>“、”<code>vo</code>“ 三段，则可以认为 “<code>(vo)(l)(vo)</code>” 是段式回文（分为 3 段）。</p>
<a id="more"></a>

<p>给你一个字符串 <code>text</code>，在确保它满足段式回文的前提下，请你返回 <strong>段</strong> 的 <strong>最大数量</strong> <code>k</code>。</p>
<p>如果段的最大数量为 <code>k</code>，那么存在满足以下条件的 <code>a_1, a_2, ..., a_k</code>：</p>
<ul>
<li>每个 <code>a_i</code> 都是一个非空字符串；</li>
<li>将这些字符串首位相连的结果 <code>a_1 + a_2 + ... + a_k</code> 和原始字符串 <code>text</code> 相同；</li>
<li>对于所有<code>1 &lt;= i &lt;= k</code>，都有 <code>a_i = a_&#123;k+1 - i&#125;</code>。</li>
</ul>
<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text &#x3D; &quot;ghiabcdefhelloadamhelloabcdefghi&quot;</span><br><span class="line">输出：7</span><br><span class="line">解释：我们可以把字符串拆分成 &quot;(ghi)(abcdef)(hello)(adam)(hello)(abcdef)(ghi)&quot;。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text &#x3D; &quot;merchant&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：我们可以把字符串拆分成 &quot;(merchant)&quot;。</span><br></pre></td></tr></table></figure>

<p><strong>示例 3：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text &#x3D; &quot;antaprezatepzapreanta&quot;</span><br><span class="line">输出：11</span><br><span class="line">解释：我们可以把字符串拆分成 &quot;(a)(nt)(a)(pre)(za)(tpe)(za)(pre)(a)(nt)(a)&quot;。</span><br></pre></td></tr></table></figure>

<p><strong>示例 4：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：text &#x3D; &quot;aaa&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：我们可以把字符串拆分成 &quot;(a)(a)(a)&quot;。</span><br></pre></td></tr></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>第一反应是通过双指针，从字符串两端逐渐向中间推进寻找相同字符串，发现后即可取出一个回文段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    [a,b,c,d,a,b,c]</span><br><span class="line">i&#x3D;0  ^           ^</span><br><span class="line">i&#x3D;1  ^-^       ^-^</span><br><span class="line">i&#x3D;2  ^-^-^   ^-^-^ 发现回文段（a,b,c）</span><br></pre></td></tr></table></figure>

<p>取出一个回文段后，我们可以继续推进，寻找下一个回文段，直到两个指针间距&lt;=1，如果这时中间部分未找到回文段，则把中间部分整个提取出作为一个回文段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    [a,b,c,d,e,a,b,c]</span><br><span class="line">i&#x3D;2  ^-^-^     ^-^-^ </span><br><span class="line">这时，中间的(d,e)为一个回文段，k&#x3D;3</span><br></pre></td></tr></table></figure>

<p>为简化算法，我们可以使用递归，即找到一对回文段后，可去掉找到的回文段，并再次调用该函数本身，<code>k=k(去除已找到的前后两个回文段)+2</code>。递归基线条件有如下3个：</p>
<ol>
<li>输入字符串长度=0，则k=0</li>
<li>输入字符串长度=1，则k=1</li>
<li>若字符串中找不到回文段，则k=1</li>
</ol>
<p>至此，我们已经可以写出代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestDecomposition</span>(<span class="params">self, text: str</span>) -&gt; int:</span></span><br><span class="line">    n:int = len(text)</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span>(n==<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    mid:int = math.floor(n/<span class="number">2.0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(mid):</span><br><span class="line">        <span class="keyword">if</span> text[<span class="number">0</span>:i+<span class="number">1</span>]==text[n-i<span class="number">-1</span>:n]:</span><br><span class="line">            <span class="keyword">return</span> self.longestDecomposition(text[i+<span class="number">1</span>:n-i<span class="number">-1</span>])+<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

<p>提交结果如下：</p>
<blockquote>
<p>执行用时: <strong>52 ms</strong></p>
<p>内存消耗: <strong>13.8 MB</strong></p>
</blockquote>
<p>用时仅击败15%，看来还有优化空间，经过考虑后，我们仅需要在当前字符<code>text[i]</code>与最后一个字符相等时，才需要对比整个字符串，所以可以对循环中的判断条件做出以下调整来节省时间：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> text[i] == text[n<span class="number">-1</span>] <span class="keyword">and</span> text[<span class="number">0</span>:i+<span class="number">1</span>]==text[n-i<span class="number">-1</span>:n]:</span><br></pre></td></tr></table></figure>

<p>修改后结果如下：</p>
<blockquote>
<p>执行用时: <strong>36 ms</strong></p>
<p>内存消耗: <strong>13.7 MB</strong></p>
</blockquote>
<p>用时击败89%提交记录。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longestDecomposition</span>(<span class="params">self, text: str</span>) -&gt; int:</span></span><br><span class="line">    n:int = len(text)</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">elif</span>(n==<span class="number">1</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">    mid:int = math.floor(n/<span class="number">2.0</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(mid):</span><br><span class="line">        <span class="keyword">if</span> text[i] == text[n<span class="number">-1</span>] <span class="keyword">and</span> text[<span class="number">0</span>:i+<span class="number">1</span>]==text[n-i<span class="number">-1</span>:n]:</span><br><span class="line">            <span class="keyword">return</span> self.longestDecomposition(text[i+<span class="number">1</span>:n-i<span class="number">-1</span>])+<span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br></pre></td></tr></table></figure>

</div></article></div></main><footer><div class="paginator"><a href="/2020/10/29/LeetCode%E7%AC%94%E8%AE%B0-%E7%94%A8DFS%E8%A7%A3%E5%86%B3%E3%80%901339-%E5%88%86%E8%A3%82%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF%E3%80%91/" class="prev">PREV</a><a href="/2020/10/22/LeetCode%E7%AC%94%E8%AE%B0-%E7%94%A8%E5%89%8D%E7%BC%80%E5%92%8C%E4%B8%8E%E5%93%88%E5%B8%8C%E8%A1%A8%E8%A7%A3%E5%86%B3%E3%80%90560-%E5%92%8C%E4%B8%BAk%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84%E3%80%91/" class="next">NEXT</a></div><div class="copyright"><p><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv">页面访问量:<span id="busuanzi_value_page_pv"></span></span></p><p>© 2018 - 2022 <a href="http://jiangyixiong.top">Yixiong Jiang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>