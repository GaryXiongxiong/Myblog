<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> LeetCode笔记-用前缀和与哈希表解决【560-和为k的子数组】 · 蒋亦雄的博客</title><meta name="description" content="LeetCode笔记-用前缀和与哈希表解决【560-和为k的子数组】 - Yixiong Jiang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://jiangyixiong.top/atom.xml" title="蒋亦雄的博客"><meta name="generator" content="Hexo 5.0.0"><link rel="alternate" href="/atom.xml" title="蒋亦雄的博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/categories/blog" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/categories/podcast" target="_self" class="nav-list-link">PODCAST</a></li><li class="nav-list-item"><a href="https://github.com/GaryXiongxiong" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/resume/" target="_self" class="nav-list-link">RESUME</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">LeetCode笔记-用前缀和与哈希表解决【560-和为k的子数组】</h1><div class="post-info">2020年10月22日</div><div class="post-content"><p>给定一个整数数组和一个整数 <strong>k，</strong>你需要找到该数组中和为 <strong>k</strong> 的连续的子数组的个数。</p>
<ul>
<li>数组的长度为 [1, 20,000]</li>
<li>数组中元素的范围是 [-1000, 1000] ，且整数 <strong>k</strong> 的范围是 [-1e7, 1e7]</li>
</ul>
<a id="more"></a>

<h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入:nums &#x3D; [1,1,1], k &#x3D; 2</span><br><span class="line">输出: 2 , [1,1] 与 [1,1] 为两种不同的情况。</span><br></pre></td></tr></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>看到这种子集合，我一开始想到了动态规划，题解如下：</p>
<p>我们做一张表对应数组<code>[a,b,c]</code>:</p>
<table>
<thead>
<tr>
<th></th>
<th>a</th>
<th>b</th>
<th>c</th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>a</td>
<td>0</td>
<td>0</td>
</tr>
<tr>
<td>b</td>
<td>a+b</td>
<td>b</td>
<td>0</td>
</tr>
<tr>
<td>c</td>
<td>a+b+c</td>
<td>b+c</td>
<td>c</td>
</tr>
</tbody></table>
<p>列为起始元素，行为结束元素</p>
<p>可以推出我们每行的值等于上一行的值加上本行对应元素。每行只填到自身。对应代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span>(<span class="params">self, nums: List[int], k: int</span>) -&gt; int:</span></span><br><span class="line">    n:int = len(nums)</span><br><span class="line">    count:int = <span class="number">0</span>;</span><br><span class="line">    <span class="comment"># 构建n*n的dp表格</span></span><br><span class="line">    dp_tensor = [[[<span class="number">0</span> <span class="keyword">for</span> row <span class="keyword">in</span> range(n)] <span class="keyword">for</span> col <span class="keyword">in</span> range(n)]]</span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(index+<span class="number">1</span>):</span><br><span class="line">            <span class="comment"># 计算并填写表格</span></span><br><span class="line">            prev:int = dp_tensor[index<span class="number">-1</span>][j] <span class="keyword">if</span> index&gt;<span class="number">0</span> <span class="keyword">else</span> <span class="number">0</span></span><br><span class="line">            dp_tensor[index][j] = prev+nums[index]</span><br><span class="line">            <span class="keyword">if</span> dp_tensor[index][j] == k:</span><br><span class="line">                count+=<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

<p>时间复杂度为<code>O(N^2)</code>感觉并没有发挥DP的优势，跟暴力穷举的时间复杂度类似了。提交后果然超时。</p>
<p>观看LeetCode相关讨论后学习到本题需要使用前缀和与哈希表解决：</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><h4 id="使用前缀和"><a href="#使用前缀和" class="headerlink" title="使用前缀和"></a>使用前缀和</h4><p>设我们有一个数组<code>A[]</code>，其中对应<code>n</code>位置的前缀和为<code>A[0]</code>累加至<code>A[n-1]</code>,依此我们可以构建前缀和数组<code>prev_sums[]</code>，当我们需要知道从<code>A[i]</code>到<code>A[j]</code>的子数组和时，我们只需计算<code>prev_sums[j+1]-prev_sums[i]</code>，对应的，我们修改代码至如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span>(<span class="params">self, nums: List[int], k: int</span>) -&gt; int:</span></span><br><span class="line">    n: int = len(nums)</span><br><span class="line">    prev_sums: List[int] = [<span class="number">0</span>]</span><br><span class="line">    count: int = <span class="number">0</span></span><br><span class="line">    <span class="comment"># 构建前缀和序列</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        prev_sums.append(prev_sums[i<span class="number">-1</span>]+nums[i<span class="number">-1</span>])</span><br><span class="line">    <span class="comment"># 双指针遍历前缀和序列寻找前缀和差为k的两个元素，并累加数量</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(i+<span class="number">1</span>):</span><br><span class="line">            <span class="keyword">if</span> k == prev_sums[i+<span class="number">1</span>]-prev_sums[j]:</span><br><span class="line">                count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

<h4 id="使用哈希表（字典）"><a href="#使用哈希表（字典）" class="headerlink" title="使用哈希表（字典）"></a>使用哈希表（字典）</h4><p>这时，时间复杂度依然为<code>O(N^2)</code>，为了进一步优化，需要想到，我们只需计算和为k的子数组数量，也就是<code>prev_sums[i+1]-prev_sums[j]=k</code>的数量，就能得出最后的答案。我们可以利用字典中查找<code>key</code>复杂度只为<code>O(1)</code>的特性，把每个<code>prev_sum</code>存储到一个字典的<code>key</code>中，同时把该<code>prev_sum</code>的个数存储到值中。同时在循环中我们只考虑<code>j&lt;=i</code>的情况，所以我们只需要维护一个存储key为<code>prev_sum</code>，值为<code>prev_sum的个数</code>的字典，遍历一次，在遍历过程中，计算出<code>当前prev_sum-k</code>的值，并在字典中查找这个key，如果有对应的值则把值加到<code>count</code>上，最后得出答案。</p>
<h2 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">subarraySum</span>(<span class="params">self, nums: List[int], k: int</span>) -&gt; int:</span></span><br><span class="line">    n: int = len(nums)</span><br><span class="line">    prev_sum = <span class="number">0</span></span><br><span class="line">    prev_sum_map = &#123;<span class="number">0</span> : <span class="number">1</span>&#125;</span><br><span class="line">    count: int = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, n+<span class="number">1</span>):</span><br><span class="line">        <span class="comment"># 计算i-1元素的前缀和</span></span><br><span class="line">        prev_sum+=nums[i<span class="number">-1</span>]</span><br><span class="line">        <span class="comment"># 在字典中查找 prev_sum-k，如果有，则说明有以当前元素为结尾的和为k的子数组，有prev_sum_map[prev_sum-k]个</span></span><br><span class="line">        <span class="keyword">if</span> prev_sum-k <span class="keyword">in</span> prev_sum_map:</span><br><span class="line">            <span class="comment"># 把以当前元素为结尾的和为k的子数组的数量加到map上</span></span><br><span class="line">            count+=prev_sum_map[prev_sum-k]</span><br><span class="line">        <span class="comment"># 更新当前元素前缀和在字典中的个数</span></span><br><span class="line">        prev_sum_map[prev_sum] = prev_sum_map.get(prev_sum,<span class="number">0</span>)+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> count</span><br></pre></td></tr></table></figure>

<p>此算法时间复杂度为<code>O(N)</code>。</p>
</div></article></div></main><footer><div class="paginator"><a href="/2020/10/26/LeetCode%E7%AC%94%E8%AE%B0-%E9%80%92%E5%BD%92%E8%A7%A3%E5%86%B3%E3%80%901147-%E6%AE%B5%E5%BC%8F%E5%9B%9E%E6%96%87%E3%80%91/" class="prev">PREV</a><a href="/2020/10/21/LeetCode%E7%AC%94%E8%AE%B0-164-%E6%9C%80%E5%A4%A7%E9%97%B4%E8%B7%9D/" class="next">NEXT</a></div><div class="copyright"><p><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv">页面访问量:<span id="busuanzi_value_page_pv"></span></span></p><p>© 2018 - 2021 <a href="http://jiangyixiong.top">Yixiong Jiang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>