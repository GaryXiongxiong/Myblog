<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> 分布式锁的Redis与Zookeeper实现 · 蒋亦雄的博客</title><meta name="description" content="分布式锁的Redis与Zookeeper实现 - Yixiong Jiang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://jiangyixiong.top/atom.xml" title="蒋亦雄的博客"><meta name="generator" content="Hexo 5.0.0"><link rel="alternate" href="/atom.xml" title="蒋亦雄的博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/categories/blog" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/categories/podcast" target="_self" class="nav-list-link">PODCAST</a></li><li class="nav-list-item"><a href="https://github.com/GaryXiongxiong" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/resume/" target="_self" class="nav-list-link">RESUME</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">分布式锁的Redis与Zookeeper实现</h1><div class="post-info">2020年10月12日</div><div class="post-content"><p>在分布式系统中，会有来自于不同实例的线程访问同一个临界资源，这时我们需要一种分布式的协调技术来对线程进行调度。其中的核心实现为分布式锁。</p>
<a id="more"></a>

<h2 id="分布式锁的特性"><a href="#分布式锁的特性" class="headerlink" title="分布式锁的特性"></a>分布式锁的特性</h2><ul>
<li>在分布式环境下，同一个临界资源\临界操作只能同时被1个机器的1个线程访问\执行。</li>
<li>高可用的锁获取与锁释放</li>
<li>高性能的锁获取与锁释放</li>
<li>可重入性，同一任务可多次获取锁</li>
<li>具备锁失效机制</li>
<li>可实现非阻塞锁</li>
</ul>
<h2 id="Redis简单实现"><a href="#Redis简单实现" class="headerlink" title="Redis简单实现"></a>Redis简单实现</h2><h4 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SETNX lock_id 1</span><br></pre></td></tr></table></figure>

<p><code>SETNX</code> 命令为“<strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists”的简写。当key不存在时返回1，key存在时返回0。当该key存在值时我们可以认为为对应id的资源加上了锁。在一个线程执行该命令时，如果返回0，则说明该资源已被加锁，获取锁失败。当返回1时，说明资源之前未被加锁，当前线程成功获取了锁。</p>
<h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DEL lock_id</span><br></pre></td></tr></table></figure>

<p><code>DEL</code> 命令通过删除lock_id来释放锁，从而使其他线程在运行<code>SETNX lock_id</code>时可以获取到锁。</p>
<h4 id="防止死锁"><a href="#防止死锁" class="headerlink" title="防止死锁"></a>防止死锁</h4><p>如果一个线程在加锁后，还没来得及解锁便崩溃了，就会导致这个锁无人释放从而形成死锁。为了防止这种情况，我们需要给锁设置超时时间。如果简单的使用下方的语句设置超时会产生问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPIRE lock_id 30</span><br></pre></td></tr></table></figure>

<p>产生问的原因是，<code>SETNX</code>与<code>EXPIRE</code>两次操作之间是非原子性的，也就会导致如果线程在运行<code>SETNX</code>和<code>EXPIRE</code>之间崩溃了，会产生死锁。对此正确的解决方式为使用如下语句：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lock_id 1 NX EX 30</span><br></pre></td></tr></table></figure>

<p>其中<code>NX</code>与<code>EX</code>为Redis在2.6.12版本后引入的<code>SET</code>命令选项，<code>NX</code>类似<code>SETNX</code>，仅在key不存在时使<code>SET</code>生效。<code>EX</code>为设置该key的过期时间。具体的选项可见官方文档<a target="_blank" rel="noopener" href="http://www.redis.cn/commands/set.html">SET key value [EX seconds] [PX milliseconds] [NX|XX]</a>。</p>
<h4 id="防止误删"><a href="#防止误删" class="headerlink" title="防止误删"></a>防止误删</h4><p>在一些情况下可能会导致锁误删，即线程获取的锁被其他线程删除。为了防止这种情况，我们可以将锁的值设定为线程或客户端的id：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SET lock_id THREAD_ID NX EX 30</span><br></pre></td></tr></table></figure>

<p>之后在删除前获取该锁的值，与自身id进行比较，仅在id相同时才删除锁，这样就会涉及执行两条命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET lock_id</span><br><span class="line"># 若id相同：</span><br><span class="line">DEL lock_id</span><br></pre></td></tr></table></figure>

<p>看到执行两条命令，我们就又发现了问题：这个操作没有原子性，如果在<code>GET</code>命令和<code>DEL</code>命令之间，锁的值发生了变化，那就还会产生误删的情况。为了解决这个问题，官方给出的<a target="_blank" rel="noopener" href="https://redis.io/topics/distlock">解决方案</a>是Lua脚本：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EVAL &quot;if redis.call(&#39;get&#39;,KEYS[1]) &#x3D;&#x3D; ARGV[1] then return redis.call(&#39;del&#39;,KEYS[1]) else return 0 end&quot; 1 lock_id THREAD_ID</span><br></pre></td></tr></table></figure>

<p>其中<code>EVAL</code>第一个参数为Lua语句，第二个参数为个数(此例中为一个key和一个参数)。之后的参数为key和传入Lua的参数。Redis执行Lua脚本具有原子性，执行的Lua如下：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> redis.call(<span class="string">&quot;get&quot;</span>,KEYS[<span class="number">1</span>]) == ARGV[<span class="number">1</span>] <span class="keyword">then</span></span><br><span class="line">    <span class="keyword">return</span> redis.call(<span class="string">&quot;del&quot;</span>,KEYS[<span class="number">1</span>])</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>

<p>至此我们完成了简单的Redis锁实现。</p>
<h2 id="ZooKeeper分布式锁原理"><a href="#ZooKeeper分布式锁原理" class="headerlink" title="ZooKeeper分布式锁原理"></a>ZooKeeper分布式锁原理</h2><h4 id="ZooKeeper的四种节点"><a href="#ZooKeeper的四种节点" class="headerlink" title="ZooKeeper的四种节点"></a>ZooKeeper的四种节点</h4><ul>
<li>持久节点（PERSISTENT）默认的节点类型。创建节点的客户端与 Zookeeper 断开连接后，该节点依旧存在。</li>
<li>持久节点顺序节点（PERSISTENT_SEQUENTIAL）所谓顺序节点，就是在创建节点时，Zookeeper 根据创建的时间顺序给该节点名称进行编号。</li>
<li>临时节点（EPHEMERAL）和持久节点相反，当创建节点的客户端与 Zookeeper 断开连接后，临时节点会被删除。</li>
<li>临时顺序节点（EPHEMERAL_SEQUENTIAL）顾名思义，临时顺序节点结合和临时节点和顺序节点的特点：在创建节点时，Zookeeper 根据创建的时间顺序给该节点名称进行编号；当创建节点的客户端与 Zookeeper 断开连接后，临时节点会被删除。</li>
</ul>
<h4 id="加锁-1"><a href="#加锁-1" class="headerlink" title="加锁"></a>加锁</h4><p>首先，在 Zookeeper 当中创建一个持久节点 。当第一个客户端想要获得锁时，需要在这个节点下面创建一个<strong>临时顺序节点</strong> Lock1。</p>
<p>之后，Client1 查找 该节点下面所有的临时顺序节点并排序，判断自己所创建的节点 Lock1 是不是顺序最靠前的一个。如果是第一个节点，则成功获得锁。</p>
<p>Client2 查找下面所有的临时顺序节点并排序，判断自己所创建的节点 Lock2 是不是顺序最靠前的一个，结果发现节点 Lock2 并不是最小的。于是，Client2 向排序仅比它靠前的节点 Lock1 注册 Watcher，用于监听 Lock1 节点是否存在。这意味着 Client2 抢锁失败，进入了等待状态。这便形成了一个等待队列</p>
<h4 id="解锁"><a href="#解锁" class="headerlink" title="解锁"></a>解锁</h4><p>当任务完成时，Client1 会显示调用删除节点 Lock1 的指令。由于 Client2 一直监听着 Lock1 的存在状态，当 Lock1 节点被删除，Client2 会立刻收到通知。这时候 Client2 会再次查询 父节点下面的所有节点，确认自己创建的节点 Lock2 是不是目前最小的节点。如果是最小，则 Client2 顺理成章获得了锁。</p>
<h4 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZkLockImpl</span> <span class="keyword">implements</span> <span class="title">ZkLock</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(ZkLock.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String lockPath;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ZkClient zkClient;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; curNode = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;String&gt; preNode = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructor for basic ZkLock</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> servers Servers list for zookeeper, see &#123;<span class="doctag">@link</span> ZkClient#ZkClient(java.lang.String, int, int)&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> sessionTimeout Session Timeout for zookeeper, see &#123;<span class="doctag">@link</span> ZkClient#ZkClient(java.lang.String, int, int)&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> connectionTimeout Connection Timeout for zookeeper, see &#123;<span class="doctag">@link</span> ZkClient#ZkClient(java.lang.String, int, int)&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> lockPath the path of this lock in zookeeper</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZkLockImpl</span><span class="params">(String servers, <span class="keyword">int</span> sessionTimeout, <span class="keyword">int</span> connectionTimeout, String lockPath)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.lockPath = lockPath;</span><br><span class="line">        <span class="keyword">this</span>.zkClient = <span class="keyword">new</span> ZkClient(servers, sessionTimeout, connectionTimeout);</span><br><span class="line">        <span class="keyword">if</span>(!zkClient.exists(lockPath))&#123;</span><br><span class="line">            zkClient.createPersistent(lockPath);</span><br><span class="line">            LOG.info(<span class="string">&quot;Connected to [&#123;&#125;], lock path:[&#123;&#125;] created&quot;</span>,servers,lockPath);</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            LOG.info(<span class="string">&quot;Connected to [&#123;&#125;], lock path:[&#123;&#125;] existed&quot;</span>,servers,lockPath);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Try if the thread occupied lock currently.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> Ture if thread occupied the lock</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        List&lt;String&gt; lockQueue = zkClient.getChildren(lockPath);</span><br><span class="line">        Collections.sort(lockQueue);</span><br><span class="line">        <span class="keyword">if</span>(lockQueue.size()&gt;<span class="number">0</span>&amp;&amp;(lockPath+<span class="string">&quot;/&quot;</span>+lockQueue.get(<span class="number">0</span>)).equals(curNode.get()))&#123;</span><br><span class="line">            LOG.debug(<span class="string">&quot;Lock [&#123;&#125;] acquired&quot;</span>,lockPath);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">int</span> index = lockQueue.indexOf(curNode.get().substring(lockPath.length()+<span class="number">1</span>));</span><br><span class="line">            preNode.set(lockPath+<span class="string">&quot;/&quot;</span>+lockQueue.get(index-<span class="number">1</span>));</span><br><span class="line">            LOG.debug(<span class="string">&quot;Lock [&#123;&#125;] is occupied, set preNode to [&#123;&#125;]&quot;</span>,lockPath,preNode.get());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CountDownLatch latch = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        IZkDataListener listener = <span class="keyword">new</span> IZkDataListener() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataChange</span><span class="params">(String dataPath, Object data)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleDataDeleted</span><span class="params">(String dataPath)</span> </span>&#123;</span><br><span class="line">                LOG.debug(<span class="string">&quot;Node [&#123;&#125;] has been deleted&quot;</span>,dataPath);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>==curNode.get())&#123;</span><br><span class="line">            curNode.set(zkClient.createEphemeralSequential(lockPath+<span class="string">&quot;/&quot;</span>,<span class="string">&quot;Lock&quot;</span>));</span><br><span class="line">            LOG.debug(<span class="string">&quot;curNode [&#123;&#125;] has been created&quot;</span>,curNode.get());</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> LockException(<span class="string">&quot;ZkLock is not reentrant&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!tryLock()&amp;&amp;zkClient.exists(preNode.get()))&#123;</span><br><span class="line">            zkClient.subscribeDataChanges(preNode.get(),listener);</span><br><span class="line">            <span class="keyword">while</span>(zkClient.exists(preNode.get())&amp;&amp;!tryLock())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    LOG.debug(<span class="string">&quot;Thread blocked in lock [&#123;&#125;]&quot;</span>,lockPath);</span><br><span class="line">                    latch.await();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    LOG.error(e.getMessage());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            zkClient.unsubscribeDataChanges(preNode.get(),listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">releaseLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span>!=curNode.get()&amp;&amp;zkClient.exists(curNode.get())&amp;&amp;tryLock())&#123;</span><br><span class="line">            <span class="keyword">if</span>(zkClient.delete(curNode.get()))&#123;</span><br><span class="line">                LOG.debug(<span class="string">&quot;Lock [&#123;&#125;] released, Node [&#123;&#125;] deleted&quot;</span>,lockPath,curNode.get());</span><br><span class="line">                curNode.remove();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        LOG.error(<span class="string">&quot;Illegally lock release&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>项目见我的<a target="_blank" rel="noopener" href="https://github.com/GaryXiongxiong/ZkLock">GitHub</a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a target="_blank" rel="noopener" href="http://www.imodou.com.cn/article/67">http://www.imodou.com.cn/article/67</a></p>
<p><a target="_blank" rel="noopener" href="https://www.funtl.com/zh/apache-dubbo-zookeeper/Zookeeper-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html#zookeeper-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86">https://www.funtl.com/zh/apache-dubbo-zookeeper/Zookeeper-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81.html#zookeeper-%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E5%8E%9F%E7%90%86</a></p>
</blockquote>
</div></article></div></main><footer><div class="paginator"><a href="/2020/10/21/LeetCode%E7%AC%94%E8%AE%B0-164-%E6%9C%80%E5%A4%A7%E9%97%B4%E8%B7%9D/" class="prev">上一篇</a><a href="/2020/09/22/JWT%E5%8E%9F%E7%90%86%E4%B8%8E%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E7%A4%BA%E4%BE%8B/" class="next">下一篇</a></div><div class="copyright"><p>© 2015 - 2020 <a href="http://jiangyixiong.top">Yixiong Jiang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>