<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><title> LeetCode笔记 用动态规划解决【120 三角形最小路径和】 · 蒋亦雄的博客</title><meta name="description" content="LeetCode笔记 用动态规划解决【120 三角形最小路径和】 - Yixiong Jiang"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/favicon.png"><link rel="stylesheet" href="/css/apollo.css"><link rel="search" type="application/opensearchdescription+xml" href="http://jiangyixiong.top/atom.xml" title="蒋亦雄的博客"><meta name="generator" content="Hexo 5.0.0"><link rel="alternate" href="/atom.xml" title="蒋亦雄的博客" type="application/atom+xml">
</head><body><div class="wrap"><header><a href="/" class="logo-link"><img src="/favicon.png" alt="logo"></a><ul class="nav nav-list"><li class="nav-list-item"><a href="/categories/blog" target="_self" class="nav-list-link">BLOG</a></li><li class="nav-list-item"><a href="/categories/podcast" target="_self" class="nav-list-link">PODCAST</a></li><li class="nav-list-item"><a href="https://github.com/GaryXiongxiong" target="_blank" class="nav-list-link">GITHUB</a></li><li class="nav-list-item"><a href="/resume/" target="_self" class="nav-list-link">RESUME</a></li><li class="nav-list-item"><a href="/atom.xml" target="_self" class="nav-list-link">RSS</a></li></ul></header><main class="container"><div class="post"><article class="post-block"><h1 class="post-title">LeetCode笔记 用动态规划解决【120 三角形最小路径和】</h1><div class="post-info">2021年1月28日</div><div class="post-content"><p>给定一个三角形 <code>triangle</code> ，找出自顶向下的最小路径和。</p>
<p>每一步只能移动到下一行中相邻的结点上。<strong>相邻的结点</strong> 在这里指的是 <strong>下标</strong> 与 <strong>上一层结点下标</strong> 相同或者等于 <strong>上一层结点下标 + 1</strong> 的两个结点。也就是说，如果正位于当前行的下标 <code>i</code> ，那么下一步可以移动到下一行的下标 <code>i</code> 或 <code>i + 1</code> 。</p>
<a id="more"></a>

<p><strong>示例 1：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：triangle &#x3D; [[2],[3,4],[6,5,7],[4,1,8,3]]</span><br><span class="line">输出：11</span><br><span class="line">解释：如下面简图所示：</span><br><span class="line">   2</span><br><span class="line">  3 4</span><br><span class="line"> 6 5 7</span><br><span class="line">4 1 8 3</span><br><span class="line">自顶向下的最小路径和为 11（即，2 + 3 + 5 + 1 &#x3D; 11）。</span><br></pre></td></tr></table></figure>

<p><strong>示例 2：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：triangle &#x3D; [[-10]]</span><br><span class="line">输出：-10</span><br></pre></td></tr></table></figure>

<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h4 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h4><p>此题很容易想到使用贪心算法求解，既从顶点开始，每一步都选择值最小的点向下前进。在示例提供的数据中这种算法可以找到最优解。但需要考虑在一些情况下，贪心算法仅能找到局部最优解，例如：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   2</span><br><span class="line">  3 4</span><br><span class="line"> 8 9 1</span><br><span class="line">7 6 5 2</span><br><span class="line">本例使用贪心算法获取的路径为：（2-3-8-6）但实际最优解为（2-4-1-2）</span><br></pre></td></tr></table></figure>

<h4 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h4><p>这道题目其实类似于背包问题，天然适用与动态规划，甚至于我们可以直接在现有的三角形上构建动态规划矩阵。核心思路为：</p>
<ul>
<li>计算第一行节点的最小路径和（其实就是数字本身，不用做处理）</li>
<li>从第二行开始，根据当前行与上一行，计算到每一行各个节点的最小路径和</li>
<li>找到最后一行中最小的路径和节点，即为这个三角形的最小路径和</li>
</ul>
<p>例如刚才提到的三角形：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">   2</span><br><span class="line">  3 4</span><br><span class="line"> 8 9 1</span><br><span class="line">7 6 5 2</span><br></pre></td></tr></table></figure>

<p>计算第二行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  (2)</span><br><span class="line"> (5 6)</span><br><span class="line"> 8 9 1</span><br><span class="line">7 6 5 2</span><br></pre></td></tr></table></figure>

<p>计算第三行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   (2)</span><br><span class="line">  (5 6)</span><br><span class="line">(13 14 7)</span><br><span class="line"> 7 6 5 2</span><br><span class="line">其中，9这个节点既可从5到达，也可从6到达，我们只需计算最小从5到达的路径和即可</span><br></pre></td></tr></table></figure>

<p>计算最后一行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">    (2)</span><br><span class="line">   (5 6)</span><br><span class="line"> (13 14 7)</span><br><span class="line">(20 19 12 9)</span><br></pre></td></tr></table></figure>

<p>通过取最后一行的最小值，即可获取最小路径和：9</p>
<h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>思路清晰之后直接上代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">minimumTotal</span>(<span class="params">self, triangle: List[List[int]]</span>) -&gt; int:</span></span><br><span class="line">        <span class="keyword">for</span> coloumIndex,row <span class="keyword">in</span> enumerate(triangle):</span><br><span class="line">            <span class="keyword">if</span> coloumIndex&gt;<span class="number">0</span>:</span><br><span class="line">                <span class="comment"># 最左边元素仅可从上一行的最左边元素到达</span></span><br><span class="line">                row[<span class="number">0</span>] += triangle[coloumIndex<span class="number">-1</span>][<span class="number">0</span>]</span><br><span class="line">                <span class="comment"># 最右边元素仅可从上一行最右边元素到达</span></span><br><span class="line">                row[<span class="number">-1</span>] += triangle[coloumIndex<span class="number">-1</span>][<span class="number">-1</span>]</span><br><span class="line">                <span class="comment"># 其余元素可从上一行的2个元素到达，取最小计算路径和</span></span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>,coloumIndex):</span><br><span class="line">                    row[i]+=min(triangle[coloumIndex<span class="number">-1</span>][i<span class="number">-1</span>],triangle[coloumIndex<span class="number">-1</span>][i])</span><br><span class="line">        <span class="comment"># 返回最后一行中最小的路径和</span></span><br><span class="line">        <span class="keyword">return</span> min(triangle[<span class="number">-1</span>])</span><br></pre></td></tr></table></figure>

</div></article></div></main><footer><div class="paginator"><a href="/2021/05/25/%E6%97%B6%E9%97%B4%E7%9A%84%E5%BE%80%E4%BA%8B%E2%80%94%E2%80%94%E8%AE%B0%E4%B8%80%E6%AC%A1%E4%B8%8E%E5%A4%8F%E4%BB%A4%E6%97%B6%E7%9A%84%E6%96%97%E6%99%BA%E6%96%97%E5%8B%87/" class="prev">PREV</a><a href="/2021/01/25/%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BA%E6%98%93%E4%BA%8E%E6%89%93%E7%90%86%E7%9A%84%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2-%E5%9F%BA%E4%BA%8EGithub%20Pages%E4%B8%8EActions%E7%9A%84%E5%8D%9A%E5%AE%A2%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/" class="next">NEXT</a></div><div class="copyright"><p><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><span id="busuanzi_container_page_pv">页面访问量:<span id="busuanzi_value_page_pv"></span></span></p><p>© 2018 - 2022 <a href="http://jiangyixiong.top">Yixiong Jiang</a>, powered by <a href="https://hexo.io/" target="_blank">Hexo</a> and <a href="https://github.com/pinggod/hexo-theme-apollo" target="_blank">hexo-theme-apollo</a>.</p></div></footer></div><script async src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js?config=TeX-MML-AM_CHTML" integrity="sha384-crwIf/BuaWM9rM65iM+dWFldgQ1Un8jWZMuh3puxb8TOY9+linwLoI7ZHZT+aekW" crossorigin="anonymous"></script></body></html>